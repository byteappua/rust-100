# Day 52: 持久化机制 (AOF)

内存数据库虽然速度快，但一旦重启数据就会丢失。为了解决这个问题，我们需要引入**持久化**机制。

Redis 主要支持两种持久化方式：
1.  **RDB (Redis Database)**: 定期将内存快照保存到磁盘。
2.  **AOF (Append Only File)**: 记录服务器接收到的每一个写命令。重启时重新执行这些命令即可恢复数据。

考虑到实现的复杂度与教学目的，我们将实现一个简化版的 **AOF** 持久化。

## 1. AOF 原理

AOF 的核心逻辑非常简单：
1.  当服务器执行一个写命令（如 `SET`）成功后。
2.  将该命令以 RESP 协议格式追加写入到 AOF 文件中。
3.  服务器启动时，读取 AOF 文件，逐条回放命令。

## 2. 序列化命令

我们需要将 `Command` 结构体转换回 RESP 字节流。这其实就是解析的逆过程。

例如 `SET key value` 需要转换为：
`*3\r\n$3\r\nSET\r\n$3\r\nkey\r\n$5\r\nvalue\r\n`

## 3. 异步写入

为了不阻塞主线程，文件写入通常也应该是异步的，或者使用缓冲。在 Tokio 中，我们可以使用 `tokio::fs::File` 和 `BufWriter`。

但为了简化，我们暂时可以使用同步的 `std::fs` 配合 `BufWriter` 在独立的线程或者在该教学阶段暂且容忍少量的阻塞（或者使用 `tokio::fs`）。考虑到这是异步项目，我们尽量使用 `tokio::fs`。

不过，AOF 写入通常需要保证顺序，最简单的做法是在处理完命令后，await 写入操作。

## 4. 架构调整

我们需要在 `process` 处理循环中，引入 `Aof` 处理器。

```rust
struct Aof {
    file: File, // tokio::fs::File
}
```
