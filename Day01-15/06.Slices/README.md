# Day 06: 切片 (Slices)

## 📝 学习目标
- 理解什么是切片 (Slice) 以及它为什么重要
- 掌握字符串切片 (`&str`) 的创建和使用
- 掌握数组切片的用法
- 理解切片与所有权的关系（借用，无所有权）

## 🎯 为什么要学这个
切片是 Rust 中处理集合数据的核心工具之一。
- **高效**：切片只是对现有数据的引用，不需要复制数据，因此非常轻量高效。
- **安全**：切片确保你访问的数据范围是有效的，编译器会帮你检查越界（运行时 panic，但编译期借用检查能防止数据失效）。
- **通用**：编写接收切片 (`&str`, `&[T]`) 而不是具体类型 (`String`, `Vec<T>`) 的函数，可以增加代码的复用性。

## 📖 核心概念

### 1. 什么是切片？
切片 (Slice) 允许你引用集合中一段连续的元素序列，而不需要引用整个集合。
切片是一种 **引用**，所以它 **没有所有权**。

### 2. 字符串切片 (String Slices)
字符串切片是指向 `String` 中一部分内容的引用。类型标记为 `&str`。

```rust
let s = String::from("hello world");

let hello = &s[0..5];
let world = &s[6..11];
```
内部结构：切片存储了一个指向起始位置的指针和一个长度。

#### Range 语法
使用 `[starting_index..ending_index]`：
*   从 `starting_index` 开始（包含）。
*   到 `ending_index` 结束（不包含）。

**简写形式**：
```rust
let s = String::from("hello");
let len = s.len();

let slice = &s[0..2];
let slice = &s[..2]; // 省略开头，默认为 0

let slice = &s[3..len];
let slice = &s[3..]; // 省略结尾，默认为 len

let slice = &s[0..len];
let slice = &s[..]; // 引用整个字符串
```

### 3. 字符串字面值就是切片
我们经常使用的字符串字面值：
```rust
let s = "Hello, world!";
```
这里的 `s` 的类型其实就是 `&str`。它是一个指向二进制程序特定位置的切片。这也是为什么字符串字面值是不可变的。

### 4. 数组切片
不仅仅是字符串，数组也可以有切片。类型标记为 `&[T]`。

```rust
let a = [1, 2, 3, 4, 5];
let slice = &a[1..3]; // 类型是 &[i32]
assert_eq!(slice, &[2, 3]);
```

### 5. 切片作为函数参数
**最佳实践**：如果你的函数只需要读取数据而不需要拥有它，尽量使用切片作为参数。

```rust
// ❌ 不推荐：只能接收 String
fn first_word(s: &String) -> &str { ... }

// ✅ 推荐：可以接收 String 的切片，也可以接收字符串字面值
fn first_word(s: &str) -> &str { ... }
```
这样，`first_word`既可以接受 `String` (通过 `&String` 或 `&s[..]`)，也可以接受 `&str`。

## 💻 代码示例

### 示例: 获取第一个单词
```rust
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes(); // 转换为字节数组以遍历

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i]; // 找到空格，返回之前的切片
        }
    }

    &s[..] // 没有空格，返回整个字符串
}
```

## 🏋️ 练习题

我们为你准备了关于切片操作的练习题。

- **练习 1**: 字符串切片基础
- **练习 2**: 数组切片
- **练习 3**: 实现 `first_word`

👉 **[点击这里查看练习题](./exercises/README.md)**

## 🤔 常见问题 (FAQ)

### Q1: 切片会导致所有权转移吗？
A: 不会。切片是引用，它借用了原本的数据。原数据的所有者必须在切片使用期间保持有效。

### Q2: 为什么 `s[0..1]` 处理中文会报错？
A: Rust 的 `String` 是 UTF-8 编码的。一个中文字符通常占 3 个字节。`s[0..1]` 试图切取第 1 个字节，但这只是中文字符的一部分，不是合法的字符边界。Rust 为了防止产生无效字符串，会直接 panic。
**解决**：使用 `chars()` 迭代器，或者确保切片索引在字符边界上（如 `0..3`）。

### Q3: `&String` 和 `&str` 有什么区别？
A: `&String` 是对 `String` 类型的引用。`&str` 是字符串切片。
由于 `String` 实现了 `Deref` trait，你可以把 `&String` 传给需要 `&str` 的函数，Rust 会自动转换（强制解引用）。但反过来不行。所以参数定义为 `&str` 更通用。

## 💡 最佳实践
- **函数参数优先使用切片**：使用 `&str` 而不是 `&String`，使用 `&[T]` 而不是 `&Vec<T>`。
- **小心 UTF-8**：对包含非 ASCII 字符的字符串做索引切片时要格外小心。

## 🔗 扩展阅读
- [Rust 程序设计语言 - 切片](https://doc.rust-lang.org/book/ch04-03-slices.html)

## 📚 本节要点回顾
- 切片是对集合中连续元素的引用。
- `&str` 是字符串切片，字面值也是 `&str`。
- `&[T]` 是数组/Vec 切片。
- Range 语法 `..` 用于指定范围。
- 切片没有所有权。

## ⏭️ 下一步
有了切片，我们可以高效地操作数据了。接下来我们将学习 Rust 中最重要的数据组织方式——结构体。

下一节: [Day 07: 结构体](../07.Structs/README.md)
