# Day 04: 所有权 (Ownership)

所有权是 Rust 最独特的特性，也是它在没有垃圾回收 (GC) 的情况下保证内存安全的关键所在。

## 1. 什么是所有权？

Rust 的核心特性就是所有权。所有程序都必须管理其运行时使用计算机内存的方式。
*   有些语言有垃圾回收机制（如 Java, Python）。
*   有些语言需要程序员显式分配和释放内存（如 C, C++）。
*   Rust 采用了第三种方式：内存通过一个所有权系统来管理，其中包含一组在编译时检查的规则。

### 所有权规则

1.  Rust 中的每一个值都有一个被称为其 **所有者 (Owner)** 的变量。
2.  值在任一时刻有且只有一个所有者。
3.  当所有者（变量）离开作用域，这个值将被丢弃。

## 2. 变量作用域

作用域是一个项（item）在程序中有效的范围。

```rust
{                      // s 在这里无效，它尚未声明
    let s = "hello";   // 从这里开始，s 是有效的
    // 使用 s
}                      // 此作用域结束，s 不再有效
```

## 3. String 类型

为了演示所有权，我们需要一个比基本标量类型更复杂的数据类型。`String` 是存储在堆上的，所以我们需要考虑内存的分配和释放。

```rust
let s = String::from("hello");
```

## 4. 内存与分配

*   **栈 (Stack)**: 存储编译时大小已知的数据（如 i32, bool）。访问速度快。
*   **堆 (Heap)**: 存储编译时大小未知或可能变化的数据（如 String）。访问速度慢，需要分配器寻找空间。

当变量离开作用域时，Rust 会自动调用一个特殊的函数 `drop`，释放内存。

### 变量与数据交互的方式：移动 (Move)

```rust
let x = 5;
let y = x; // 复制 x 的值给 y，因为 i32 实现了 Copy trait
```

```rust
let s1 = String::from("hello");
let s2 = s1;
// println!("{}, world!", s1); // 错误！s1 已经失效
```

为了保证内存安全（避免二次释放），Rust 认为 `s1` 不再有效。这个操作被称为 **移动 (Move)**。

### 变量与数据交互的方式：克隆 (Clone)

如果我们确实需要深度复制堆上的数据，可以使用 `clone` 方法。

```rust
let s1 = String::from("hello");
let s2 = s1.clone();
println!("s1 = {}, s2 = {}", s1, s2);
```

### 只在栈上的数据：拷贝 (Copy)

如果一个类型拥有 `Copy` trait，一个变量赋值给另一个变量后，原来的变量仍然有效。
比如所有整数类型、布尔类型、浮点数类型、字符类型、包含 Copy 类型的元组。

## 5. 所有权与函数

将值传递给函数与给变量赋值的语义类似。向函数传递值可能会移动或者复制，就像赋值语句一样。

```rust
fn main() {
    let s = String::from("hello");
    takes_ownership(s);
    // s 在这里不再有效

    let x = 5;
    makes_copy(x);
    // x 在这里仍然有效
}
```

## 6. 返回值与作用域

返回值也可以转移所有权。

```rust
fn main() {
    let s1 = gives_ownership();
    let s2 = String::from("hello");
    let s3 = takes_and_gives_back(s2);
}
```
