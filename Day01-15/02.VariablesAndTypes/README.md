# Day 02: 变量与数据类型

## 📝 学习目标
- 理解 Rust 中的变量不可变性 (Immutability)
- 掌握如何定义可变变量 (`mut`)
- 了解常量 (`const`) 与变量的区别
- 理解变量隐藏 (Shadowing) 的机制
- 熟悉 Rust 的基本数据类型 (标量类型和复合类型)

## 🎯 为什么要学这个
变量和数据类型是任何编程语言的基石。在 Rust 中，这些概念尤为特殊：
- **默认不可变**：这是 Rust 内存安全和并发安全设计的核心，强迫你思考数据的变化。
- **静态强类型**：Rust 编译器在编译期就能捕获大量类型错误，避免运行时的崩溃。
- **隐藏 (Shadowing)**：提供了一种优雅的方式来处理变量转换，而无需创建临时变量名。

## 📖 核心概念

### 1. 变量与可变性

在 Rust 中，变量默认是**不可变**的。一旦值被绑定到一个变量名，你就不能改变它。

#### 不可变变量
```rust
let x = 5;
// x = 6; // 编译错误！不能修改不可变变量
```

#### 可变变量
如果你需要修改变量的值，必须使用 `mut` 关键字。
```rust
let mut x = 5;
println!("The value of x is: {}", x);
x = 6;
println!("The value of x is: {}", x);
```

### 2. 常量 (Constants)
常量使用 `const` 关键字声明，必须注明类型。它们不仅不可变，而且总是不可变。
- 可以在任何作用域声明，包括全局作用域。
- 只能被设置为常量表达式，不能是函数调用的结果。

```rust
const MAX_POINTS: u32 = 100_000;
```

### 3. 隐藏 (Shadowing)
你可以声明和前面变量同名的新变量，新变量会"隐藏"旧变量。
- 使用 `let` 关键字再次声明。
- 可以改变变量的类型。
- 原变量在隐藏后不可访问，但在作用域结束后如果新变量销毁，原变量不会恢复（因为是覆盖绑定）。

```rust
let x = 5;
let x = x + 1; // x 现在是 6
let x = "spaces"; // x 现在是字符串类型
```

### 4. 数据类型

Rust 是静态类型语言，必须在编译期知道所有变量的类型。编译器通常可以根据值推断类型。

#### 标量类型 (Scalar Types)
代表一个单独的值。

- **整型**: `i8` - `i128`, `u8` - `u128`, `isize`, `usize` (基于架构)。默认为 `i32`。
- **浮点型**: `f32`, `f64`. 默认为 `f64`。
- **布尔型**: `bool` (`true`, `false`).
- **字符型**: `char`. 代表 Unicode 标量值 (4字节)。例如 `'a'`, `'ℤ'`, `'😻'`.

#### 复合类型 (Compound Types)
可以将多个值组合成一个类型。

- **元组 (Tuple)**:
  - 长度固定。
  - 可以包含不同类型。
  ```rust
  let tup: (i32, f64, u8) = (500, 6.4, 1);
  let (x, y, z) = tup; // 解构
  let five_hundred = tup.0; // 点号访问
  ```

- **数组 (Array)**:
  - 长度固定。
  - 必须包含相同类型。
  - 数据存储在栈 (stack) 上。
  ```rust
  let a = [1, 2, 3, 4, 5];
  let first = a[0];
  let months = ["January", "February", "March"];
  ```

## 💻 代码示例

### 示例 1: 变量与可变性
```rust
fn main() {
    let x = 5;
    println!("x = {}", x);
    // x = 6; // 错误

    let mut y = 10;
    println!("y = {}", y);
    y = 20;
    println!("y updated = {}", y);
}
```

### 示例 2: 变量隐藏
```rust
fn main() {
    let spaces = "   "; // 字符串类型
    let spaces = spaces.len(); // usize 类型
    println!("Spaces length: {}", spaces);
}
```

### 示例 3: 数学运算
```rust
fn main() {
    // 加法
    let sum = 5 + 10;
    // 减法
    let difference = 95.5 - 4.3;
    // 乘法
    let product = 4 * 30;
    // 除法
    let quotient = 56.7 / 32.2;
    let floored = 2 / 3; // 结果为 0
    // 取余
    let remainder = 43 % 5;

    println!("Sum: {}", sum);
}
```

## 🏋️ 练习题

我们为你准备了专门的练习题来巩固这些概念。

- **练习 1**: 变量绑定与可变性
- **练习 2**: 基本数据类型的使用
- **练习 3**: 元组和数组的操作

👉 **[点击这里查看练习题](./exercises/README.md)**

## 🤔 常见问题 (FAQ)

### Q1: 为什么 Rust 默认变量是不可变的？
A: 这是一个权衡。不可变性使得代码更易于推理（尤其是在并发环境下），消除了"数据竞争"的一大来源。当你明确需要修改数据时，`mut` 关键字作为一个显式的标记，提醒读者注意这里的状态变化。

### Q2: `let` 隐藏 (Shadowing) 和 `mut` 有什么区别？
A:
1. `mut` 允许你改变同一个变量绑定的**值**，但不能改变**类型**。
2. Shadowing 是使用 `let` 声明了一个**全新**的变量，只是名字相同。它可以改变**类型**，也可以改变**可变性**（例如从可变变为不可变）。

### Q3: 什么时候应该用数组，什么时候用 Vector？
A: 数组长度是固定的，分配在栈上，速度快。如果你知道元素的数量不会改变（比如月份、一周的天数），用数组。如果你需要动态增删元素，使用标准库提供的 `Vec<T>`（向量）。

## 💡 最佳实践
- **优先不可变**：除非你确定需要修改它，否则不要加 `mut`。
- **显式类型标注**：虽然编译器能推断类型，但在定义复杂类型或公共 API 时，显式标注类型能提高代码可读性。
- **使用下划线**：在数字字面量中使用 `_` 提高可读性，如 `1_000_000`。
- **未使用的变量**：如果声明了变量但未被使用，编译器会警告。如果你是有意为之，给变量名加下划线前缀 `_x`。

## 🔗 扩展阅读
- [Rust 程序设计语言 - 变量和可变性](https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html)
- [Rust 程序设计语言 - 数据类型](https://doc.rust-lang.org/book/ch03-02-data-types.html)

## 📚 本节要点回顾
- 变量默认不可变，需用 `mut` 声明可变。
- 常量 `const` 始终不可变且需标注类型。
- Shadowing 允许重用变量名并改变类型。
- 标量类型包括整数、浮点数、布尔值和字符。
- 复合类型包括元组（异构、定长）和数组（同构、定长）。

## ⏭️ 下一步
熟悉了数据的存储方式，接下来我们将学习如何控制程序的执行流程。

下一节: [Day 03: 函数与控制流](../03.FunctionsAndControlFlow/README.md)
